# Apple Mobile OAuth: Step-by-Step (Beginner Friendly)

This explains the interaction between a **mobile app** and **Apple** during login.
Every term is defined, and terms inside those definitions are explained too.

## Big Picture

Your app wants to prove “this user is who they say they are.”  
Apple does the **authentication** (login) and gives your app a **proof token**.  
Your backend verifies that proof and then issues your own app tokens.

## Terms (Explained Recursively)

### OAuth 2.0

An **authorization** standard that lets an app ask a provider (Apple) for permission to access user data, without the app seeing the user’s password.

### OpenID Connect (OIDC)

An **identity layer** on top of OAuth 2.0.  
It adds a special token called **id_token** so apps can confirm who the user is.

### Authorization Code Flow

The most secure OAuth flow for apps.  
The user logs in at Apple, and Apple returns a short‑lived **authorization code**.  
Your backend later exchanges that code for tokens.

### Authorization Code

A short‑lived, one‑time **string** given by Apple after the user logs in.  
It is **not** a token you can use directly.  
You exchange it at Apple’s **token endpoint**.

### Token Endpoint

A server URL where you exchange the **authorization code** for tokens.  
Apple’s token endpoint is: `https://appleid.apple.com/auth/token`.

### Token

A signed string that grants access or proves identity.  
Common types:

- **id_token** (who the user is)
- **access_token** (access to provider data)
- **refresh_token** (get new tokens without logging in again)

### id_token

A **JWT** that proves the user’s identity.  
Apple includes the user’s unique ID (`sub`) and sometimes email.

### JWT (JSON Web Token)

A compact, signed JSON object.  
It has three parts: **header**, **payload**, **signature**.

### Signature

A cryptographic proof that the token was created by Apple and not changed.

### JWKS

“JSON Web Key Set.”  
Apple publishes its public keys in a JWKS URL.  
You use these keys to verify the JWT **signature**.

### Issuer (iss)

A JWT field that says **who** created the token.  
For Apple, it should be `https://appleid.apple.com`.

### Audience (aud)

A JWT field that says **who the token is intended for**.  
It must match your Apple **client_id** (Service ID).

### client_id (Service ID)

The unique ID Apple gives to your app/service in Apple Developer Console.  
It identifies your app to Apple.

### Redirect URI

A URL or app scheme that Apple redirects back to after login.  
Example for mobile: `myapp://auth/callback`.

### State

A random string to prevent **CSRF** attacks.  
Your app creates it and checks it later to ensure the response is legit.

### CSRF

“Cross‑Site Request Forgery.”  
An attacker tricks a user’s browser or app into doing unintended actions.

### Nonce

A random string used to prevent **replay attacks**.  
Apple returns it in the `id_token` so you can confirm the token is fresh.

### Replay Attack

An attacker reuses a valid token/code to impersonate a user later.

### PKCE (Proof Key for Code Exchange)

Extra security for public clients (mobile apps).  
It prevents stolen authorization codes from being exchanged by attackers.

### code_verifier

A long random string generated by the mobile app.

### code_challenge

A hashed form of `code_verifier`:
`code_challenge = base64url(SHA256(code_verifier))`

Apple checks that the `code_verifier` you send later matches the `code_challenge` from the original login request.

### Scope

A list of permissions your app is requesting.  
For Apple login, common scopes are `openid`, `email`, `name`.

## Mobile‑to‑Apple Login Flow (Step‑by‑Step)

1. **Mobile app generates values**
   - `state`: random string
   - `nonce`: random string
   - `code_verifier`: random string
   - `code_challenge`: hash of `code_verifier`

2. **Mobile app builds Apple authorize URL**
   - Base URL: `https://appleid.apple.com/auth/authorize`
   - Includes parameters:
     - `client_id` (your Service ID)
     - `redirect_uri` (your app’s callback)
     - `response_type=code`
     - `scope=openid email name`
     - `state`, `nonce`
     - `code_challenge`, `code_challenge_method=S256`

3. **User logs in at Apple**
   - Apple shows login/consent screen.
   - User approves.

4. **Apple redirects back to the app**
   - The app receives the **authorization code**.

5. **App calls your backend**
   - `POST /auth/oauth/apple/token`
   - Sends:
     - `code`
     - `nonce`
     - `code_verifier`

6. **Backend talks to Apple**
   - Calls Apple token endpoint with:
     - `code`
     - `client_id`
     - `client_secret` (JWT signed with Apple key)
     - `code_verifier`
   - Apple returns `id_token`.

7. **Backend verifies the id_token**
   - Check **signature** using Apple’s **JWKS**.
   - Validate **issuer** and **audience**.
   - Compare returned **nonce** to the original nonce.

8. **Backend logs user in**
   - Creates or links user account.
   - Issues your own app access + refresh tokens.

## Why Mobile Needs PKCE

Mobile apps can’t safely store a **client_secret** (it’s visible in the app package).  
PKCE replaces that secret with a one‑time proof (`code_verifier`) so stolen codes can’t be reused.

## Summary

- Apple login uses OAuth + OIDC.
- The mobile app handles PKCE values.
- Your backend verifies Apple’s `id_token` and issues app tokens.  
  This keeps your app secure and standards‑compliant.
